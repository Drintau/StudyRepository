# 1. 设计模式目的
1. 提升软件的维护性、通用性和扩展性，降低软件的复杂度。核心是七大设计原则。
2. 设计模式有优点也有缺点，每种设计模式都有其适用的场景，不要为了使用设计模式而使用设计模式，切记防止“模式的滥用”。

# 2. 设计模式分类
目前公认的是23种（即：GoF设计模式）。  

|模式类型|包含的模式|
|----|:----|
|创建型模式|单例模式、工厂模式、抽象工厂模式、原型模式、建造者模式|
|结构型模式|适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式|
|行为型模式|策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式|

# 3. 各种设计模式

### 3.1 单例模式
##### 定义
系统中只有一个类的唯一实例。
##### java中创建类的方式【补充】
1. new关键字：单例模式解决这点。
2. 反射：会破坏单例模式。
3. 反序列化：会破坏单例模式，添加readResolve()方法解决。
4. 克隆：会破坏单例模式。
#### 3.1.1 饿汉式（静态常量）
##### 示例代码
```java
class A{
    // 1.构造方法私有化
    private A(){}
    // 2.本类内部创建对象实例
    private static final A instance = new A();
    // 3.对外提供公有静态方法，返回实例
    public static A getInstance(){
        return instance;
    }
}
```
##### 总结
1. 优点：写法简单，在类加载时完成实例化，避免了线程同步问题。
2. 缺点：在类加载时就完成实例化，没有达到懒加载效果；如果从始至终不使用这个对象，会造成内存浪费。
3. 结论：**推荐使用**，可能会造成内存浪费（一般不会，没有大问题）。
#### 3.1.2 饿汉式（静态代码块）
##### 示例代码
```java
class A{
    private A(){}
    private static A instance;
    static {
        instance = new A();
    }
    public static A getInstance(){
        return instance;
    }
}
```
##### 总结
1. 优缺点：与饿汉式（静态常量）一致。
2. 结论：**推荐使用**，简单起见直接用饿汉式（静态常量）。
#### 3.1.3 懒汉式（线程不安全）
##### 示例代码
```java
class A{
    private A(){}
    private static A instance;
    public static A getInstance(){
        if (instance == null) {
            instance = new A();
        }
        return instance;
    }
}
```
##### 总结
1. 优点：起到懒加载效果；但只能在单线程环境下使用。
2. 缺点：线程不安全。在多线程环境下，一个线程进入`if (instance == null)`判断语句，还未来得及往下执行，另一个线程也通过了这个判断，就会产生多个实例。
3. 结论：**不可用**。
#### 3.1.4 懒汉式（线程安全）
##### 示例代码
```java
class A{
    private A(){}
    private static A instance;
    public static synchronized A getInstance(){
        if (instance == null) {
            instance = new A();
        }
        return instance;
    }
}
```
##### 总结
1. 优点：懒加载，线程安全。
2. 缺点：效率低。每个线程想要获取类的实例时，都需要同步。
3. 结论：**不推荐使用**。
#### 3.1.5 懒汉式（双重检查，Double-Check）
##### 示例代码
```java
class A{
    private A(){}
    // volatile 保证内存可见性
    private static volatile A instance;
    public static A getInstance(){
        if (instance == null) {
            synchronized (A.class) {
                if (instance == null) {
                    instance = new A();
                }
            }
        }
        return instance;
    }
}
```
##### 总结
1. 优点：线程安全，懒加载，效率较高。
2. 结论：**推荐使用**。
#### 3.1.6 懒汉式（静态内部类）
##### 示例代码
```java
class A{
    private A(){}
    private static class B {
        private static final A INSTANCE = new A();
    }
    public static A getInstance(){
        return B.INSTANCE;
    }
}
```
##### 总结
1. 静态内部类特点（懒加载）：静态内部类B在A类被装载时不会立即初始化；当`getInstance()`被调用时才会装载B，才会实例化。
2. 优点：线程安全（JVM类加载机制保证），懒加载，效率较高。
3. 结论：**推荐使用**，但是不理解静态内部类特点看不懂代码。
#### 3.1.7 枚举
##### 示例代码
```java
public class Main {
    public static void main(String[] args){
        A a = A.INSTANCE;
        a.method1();
    }
}

enum A{
    INSTANCE;
    public void method1(){}
}
```
##### 总结
1. 优点：借助JDK1.5的枚举来实现单例模式，不仅避免多线程同步问题，而且还能防止反序列化重新创建对象。
2. 这种方式是《Effective Java》作者提倡的方式。
3. 结论：**推荐使用**。

### 3.2 工厂模式
##### 定义
定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。  
##### 概念
+ 产品：类。
+ 抽象产品：抽象类、接口。
+ 产品簇：是指由同一个工厂生产的，位于不同产品等级结构中的一组产品。
+ 产品等级：产品等级结构即产品的继承结构。
![产品簇与产品等级](images/pattern/产品簇与产品等级.png)
#### 3.2.1 简单工厂模式（不属于23种设计模式之一）
简单工厂模式是工厂模式的一种，也叫“静态工厂模式”。
##### UML类图
![简单工厂模式](images/pattern/简单工厂模式.png)
##### 总结
1. 优点：简单易懂。
2. 缺点：工厂类单一，代码臃肿，违背高聚合原则。
3. 缺点：新增一个产品，就要增加一个具体产品类，修改工厂逻辑；增加系统的复杂度，违背“开闭原则”。
4. 结论：对于产品种类相对较少且趋于不变的情况，可以考虑使用。
#### 3.2.2 工厂方法模式
##### UML类图
![工厂方法模式](images/pattern/工厂方法模式.png)
##### 总结
1. 优点：创建新产品只需多写一个相应的产品类、工厂类，无需修改之前的代码；完美符合“开闭原则”。
2. 缺点：产品增多时，类会爆炸式增长；一个抽象工厂只能生产一种产品（抽象工厂模式解决）。
3. 结论：只有一个产品等级且产品种类在一定数量内时，可以考虑使用。
#### 3.2.3 抽象工厂模式
##### UML类图
![抽象工厂模式](images/pattern/抽象工厂模式.png)
##### 总结
1. 优点：把工厂类的数量减少了。无论多少个产品等级，抽象工厂类就一个，工厂类就一套！
2. 抽象工厂中，生产的多个产品之间必须有内在联系，即产品簇。
3. 缺点：产品等级发生变化（增删），需要修改以前的所有工厂代码，违反了“开闭原则”。
4. 结论：当产品等级比较固定时，可以考虑使用抽象工厂模式；如果产品等级经常变化，则不建议使用抽象工厂模式。

### 3.3 原型模式
##### 定义
用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
#### 3.3.1 浅拷贝
##### 示例代码
1. 实现Cloneable接口。
2. 重写Object的clone方法，修改访问权限修饰符为public。
```java
public class ShallowClone implements Cloneable{
    private String name;
    private Date birthday; // 引用对象

    @Override
    public Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}
```
##### 总结
1. 优点：简单，能实现基本的拷贝。
2. 缺点：拷贝对象与原对象中的引用对象指向同一个内存地址，任何一个副本修改引用对象中的属性都会影响其他副本。
3. 结论：**不推荐使用**。
#### 3.3.2 深拷贝（重写clone方法）
##### 示例代码
浅拷贝的基础上，在clone方法中处理引用对象的拷贝。
```java
public class DeepClone implements Cloneable{
    private String name;
    private Date birthday;
    public void setBirthday(Date birthday) {this.birthday = birthday;}
    public Date getBirthday() {return birthday;}
    @Override
    public Object clone() throws CloneNotSupportedException {
        DeepClone cloneObj = (DeepClone)super.clone();
        Date copyDate = (Date)cloneObj.getBirthday().clone();
        cloneObj.setBirthday(copyDate);
        return cloneObj;
    }
}
```
##### 总结
1. 优点：解决了浅拷贝的问题。
2. 缺点：当引用对象有很多层时（即引用对象里面还有引用对象），重写clone方法的工作量非常大！
3. 结论：**不推荐使用**。
#### 3.3.3 深拷贝（序列化）
##### 示例代码
1. 实现Cloneable接口，Serializable接口。
2. 重写Object的clone方法为：把当前对象写入到内存，然后从内存反序列化对象；修改访问权限修饰符为public。
```java
public class DeepClone implements Cloneable, Serializable {
    @Override
    public Object clone() {
        try {
            // 对象写到内存
            ByteArrayOutputStream bos = new ByteArrayOutputStream();
            ObjectOutputStream oos = new ObjectOutputStream(bos);
            oos.writeObject(this);
            oos.close();

            // 从内存中取数据
            byte[] bytes = bos.toByteArray();

            ByteArrayInputStream bis = new ByteArrayInputStream(bytes);
            ObjectInputStream ois = new ObjectInputStream(bis);
            Object cloneObj = ois.readObject();
            ois.close();
            return cloneObj;
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}
```
##### 总结
1. 优点：完美的“原型模式”的实现。
2. 结论：**推荐使用**。

### 3.4 建造者模式
##### 定义
将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
##### UML类图
![建造者模式](images/pattern/建造者模式.png)
##### 总结
1. 建造者接口用于稳定建造过程，指挥者用于把指挥过程从客户端分离。
2. 指挥者依赖建造者接口，满足“依赖倒置原则”。
3. 工厂模式关注新建产品的结果；建造者模式关注新建产品的过程。

### 3.5 装饰器模式
##### 定义
在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。
##### UML类图
![装饰模式](images/pattern/装饰器模式.png)
##### 场景举例
JDK中，I/O流就是使用了装饰模式，抽象装饰类是FilterXXXXStream。
##### 总结
1. 优点：新增组件类，以及新增装饰器类，都不会违反“开闭原则”。
2. 缺点：过度使用会导致出现许多装饰器类，但已经是最优方案了。

### 3.6 适配器模式
##### 定义
将一个类的接口适配成用户所期待的接口，让那些接口不兼容的类可以一起工作。  
通俗的解释：根据已有接口，生成想要的接口。
##### UML类图
![适配器模式](images/pattern/适配器模式.png)
##### 场景举例
《Java编程思想》第四版第九章“完全解耦”例子：原本有一个类，发现它与新写的类及其类似，想把它用到新写的功能接口上面去。
##### 总结
1. 关键点：**已有接口生成新的接口**。
2. 体现“开闭原则”、“组合优于继承”。

### 3.7 组合模式
##### 定义
将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。
##### UML类图
![组合模式](images/pattern/组合模式.png)
##### 场景举例
JDK中，swing下的JXXXX各种组件就是使用组合模式。
##### 总结
1. 这个模式使用场景很固定，就是需要用到“树形结构”的地方。
2. 抽象父类具有节点和叶子要暴露的方法，但都是没有具体实现（例如抛异常），让子类去选择性实现。

### 3.8 代理模式
### 3.9 外观模式
### 3.10 桥接模式
### 3.11 享元模式

### 3.12 模板方法模式
##### 定义
定义一个算法的步骤，允许子类为一个或多个步骤提供其实践方式。
##### UML类图
![模板方法模式](images/pattern/模板方法模式.png)
##### 总结
1. 缺点：由于继承，如果模板类添加新的抽象方法，则所有子类都要改一遍。

### 3.13 策略模式
##### 定义
一个类的行为或其算法可以在运行时更改。
##### UML类图
![策略模式](images/pattern/策略模式.png)
##### 场景举例
《HeadFirst设计模式》例子类图
![策略模式例子](images/pattern/策略模式举例.png)
##### 总结
1. 关键点：**运行时替换**。
2. 体现“开闭原则”、“组合优于继承”。

### 3.14 观察者模式
##### 定义
一个对象的行为发生改变会导致一个或者多个其他对象的行为发生改变。
##### UML类图
![观察者模式](images/pattern/观察者模式.png)
##### 总结
1. 体现“开闭原则”、“依赖倒置原则”。
2. 缺点：当观察者特别多时，通知观察者是一个比较耗时的操作。
3. “观察者模式”有其他实现方式；MQ（消息队列）也有“观察者模式”的影子。

### 3.15 迭代器模式
##### 定义
提供一种方法顺序访问一个聚合对象中的各种元素，而又不暴露该对象的内部表示。
##### UML类图
![迭代器模式](images/pattern/迭代器模式.png)
##### 总结
1. 这个模式使用场景很固定，就是用于遍历聚合对象（集合）。
2. 实现方式有多种：可以是内部类实现迭代器，也可以是自身实现迭代器。

### 3.16 状态模式
##### 定义
允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。
##### UML类图
![状态模式](images/pattern/状态模式.png)
##### 总结
1. “状态模式”与“策略模式”是双胞胎。
2. “策略模式”通常由客户端显式指定context（上下文对象）的策略（行为）；“状态模式”将行为封装在状态对象中，context状态的改变会导致行为的改变。

### 3.17 责任链模式
### 3.18 命令模式
### 3.19 备忘录模式
### 3.20 访问者模式
### 3.21 中介者模式

### 3.22 解释器模式
估计是用不上的了，这个模式用于**编写一套程序**去**解释一门语言**，跟编译原理有很大关系。  
应用场景如：Python语言解释器、Spring表达式语言(SpEL)解释器。